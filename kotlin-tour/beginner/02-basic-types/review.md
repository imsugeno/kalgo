# 📝 Kotlin演習レビュー
**問題**: 基本型と算術演算 | **難易度**: beginner | **総合スコア**: 95/100点

## ✅ 正確性 (40/40点)

- **コンパイル結果**: 成功（エラーなし）
- **実行結果**:
  ```
  a + b = 22
  a - b = 12
  a * b = 85
  a / b = 3
  a % b = 2
  a.toDouble() / b = 3.4
  ```
- **模範解答との比較**: **完全一致**
- **エッジケース**: 入力読み取り・型変換・整数除算・浮動小数点除算すべて正しく処理

| 観点 | 得点 | 備考 |
|------|------|------|
| コンパイル可否 | 10/10 | 問題なし |
| 出力一致 | 20/20 | 模範解答と完全一致 |
| エッジケース | 10/10 | 整数除算と浮動小数点除算の区別が正しい |

## 🎯 Kotlinイディオム分析 (27/30点)

- **val/var の使い分け** (10/10点):
  - `val a` / `val b` と適切に `val` を使用している。再代入しない変数に正しく不変宣言を適用できている
  - 前回（01-hello-world）の `var age` の指摘を活かして改善されている点が素晴らしい

- **型推論の活用** (5/5点):
  - `val a = readln().toInt()` — 型アノテーションを省略し、右辺からの型推論に任せている
  - 前回の `: String`, `: Int` の冗長な型宣言がなくなり、Kotlinらしい簡潔なスタイルになっている

- **標準ライブラリ活用** (10/10点):
  - `readln()` を使用（`readLine()!!` より推奨される新しいAPI）
  - `toInt()`, `toDouble()` による明示的型変換を正しく使用
  - 文字列テンプレート `${a + b}` で式の埋め込みも適切

- **null安全性** (2/5点):
  - `readln()` は非null型を返すので基本的な安全性は確保されている
  - ただし `readln().toInt()` は不正入力（数値以外の文字列）で `NumberFormatException` をスローする。この問題では入力仕様が明確なので大きな問題ではないが、`toIntOrNull()` と Elvis演算子 `?:` の存在は知っておくとよい
  - Goでは `strconv.Atoi()` が `(int, error)` を返し、エラーを明示的に処理する。Kotlinでは `toIntOrNull()` がその考え方に近い

## 📐 コードスタイル (20/20点)

- **命名規則** (5/5点): `a`, `b` は問題仕様どおりの変数名で適切
- **整形** (5/5点): 4スペースインデント、宣言と出力の間の空行、一貫したフォーマット
- **冗長性排除** (10/10点): 無駄のないコード。各 `println` が明確な役割を持ち、重複なし

## 🔄 Go開発者として知っておくべきこと (8/10点)

| Goの考え方 | Kotlinの考え方 | この問題での適用 |
|-----------|--------------|---------------|
| `int / int` は整数除算（Goも同様） | `Int / Int` も整数除算。挙動は同じ | `a / b = 3` は Go と Kotlin で同じ結果 |
| `float64(a) / float64(b)` で浮動小数点除算 | `a.toDouble() / b` で片方を変換すれば十分 | Kotlinは片方が `Double` なら自動昇格される |
| `strconv.Atoi()` は `(int, error)` を返す | `toInt()` は例外をスロー、`toIntOrNull()` は `null` を返す | エラー処理の哲学の違いを意識しよう |
| `fmt.Sprintf("a + b = %d", a+b)` | `"a + b = ${a + b}"` で文字列テンプレート | フォーマット指定子なしで式を直接埋め込める |

Kotlinでは `a.toDouble() / b` のように片方のオペランドだけ変換すれば、もう一方は自動的に `Double` に昇格される。Goの `float64(a) / float64(b)` のように両方を変換する必要がない点は覚えておくとよい。

## 💡 改善の優先順位

- 🟡 **中**: `toIntOrNull()` と Elvis演算子 `?:` の存在を覚えておく — Goの `err != nil` パターンに相当するKotlinの安全な変換パターン
- 🟢 **低**: `b == 0` のゼロ除算チェック — この問題では不要だが、実務では意識する場面がある

---

**総評**: 前回のレビュー（01-hello-world）での指摘事項（`var` → `val`、冗長な型アノテーション）がすべて改善されている。`val` の使用、型推論の活用、`readln()` の選択など、Kotlinのイディオムをしっかり吸収できている。出力も模範解答と完全一致で、非常に良い解答。
